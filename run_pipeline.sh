#!/bin/bash

# flowctl-pipeline - Local Pipeline Runner
# Generated by flowctl

set -e

# Configuration
LOG_DIR="logs/flowctl-pipeline"
ENV_FILE=".env.flowctl-pipeline"
RESTART_POLICY="on-failure"
PIPELINE_NAME="flowctl-pipeline"

# Create log directory
mkdir -p "$LOG_DIR"

# Process tracking
declare -A PIDS

# Cleanup function
cleanup() {
  echo "Shutting down pipeline..."
  for pid in "${PIDS[@]}"; do
    if kill -0 "$pid" 2>/dev/null; then
      echo "Stopping process $pid"
      kill "$pid" || true
    fi
  done
  echo "Pipeline shutdown complete"
  exit 0
}

# Set up signal handling
trap cleanup SIGINT SIGTERM

# Load environment variables
if [ -f "$ENV_FILE" ]; then
  echo "Loading environment from $ENV_FILE"
  set -a
  source "$ENV_FILE"
  set +a
fi

# Health check function
check_health() {
  local url="$1"
  local max_retries="$2"
  local retry_delay="$3"
  local retries=0

  echo "Checking health at $url"
  until $(curl --output /dev/null --silent --fail "$url"); do
    retries=$((retries + 1))
    if [ "$retries" -ge "$max_retries" ]; then
      echo "Health check failed after $retries attempts"
      return 1
    fi
    echo "Health check attempt $retries failed, retrying in ${retry_delay}s..."
    sleep "$retry_delay"
  done
  echo "Health check passed"
  return 0
}

# Start all components

start_stellar_source() {
  echo "Starting stellar-source (source)..."
  
  
  
  # Create component log file
  local log_file="${LOG_DIR}/stellar_source.log"
  touch "$log_file"
  
  # Start component with environment variables
  ./stellar_live_source_datalake "--local" "--test-mode"  > "$log_file" 2>&1 &
  local pid=$!
  PIDS[stellar_source]=$pid
  echo "Started stellar-source with PID: $pid"
  
  
  # Wait for component to be healthy
  if ! check_health "http://localhost:8080/health" 30 2; then
    echo "stellar-source failed health check, exiting"
    cleanup
    exit 1
  fi
  
}

start_ttp_processor() {
  echo "Starting ttp-processor (processor)..."
  
  
  echo "Waiting for dependencies: while ! kill -0 "${PIDS[stellar_source]}" 2>/dev/null; do sleep 1; done"
  while ! kill -0 "${PIDS[stellar_source]}" 2>/dev/null; do sleep 1; done
  
  
  # Create component log file
  local log_file="${LOG_DIR}/ttp_processor.log"
  touch "$log_file"
  
  # Start component with environment variables
  ./ttp_processor_server "--local"  > "$log_file" 2>&1 &
  local pid=$!
  PIDS[ttp_processor]=$pid
  echo "Started ttp-processor with PID: $pid"
  
  
  # Wait for component to be healthy
  if ! check_health "http://localhost:8080/health" 30 2; then
    echo "ttp-processor failed health check, exiting"
    cleanup
    exit 1
  fi
  
}

start_demo_consumer() {
  echo "Starting demo-consumer (sink)..."
  
  
  echo "Waiting for dependencies: while ! kill -0 "${PIDS[ttp_processor]}" 2>/dev/null; do sleep 1; done"
  while ! kill -0 "${PIDS[ttp_processor]}" 2>/dev/null; do sleep 1; done
  
  
  # Create component log file
  local log_file="${LOG_DIR}/demo_consumer.log"
  touch "$log_file"
  
  # Start component with environment variables
  node "index.js" "--source" "localhost:50053" "--range" "409907" "409948"  > "$log_file" 2>&1 &
  local pid=$!
  PIDS[demo_consumer]=$pid
  echo "Started demo-consumer with PID: $pid"
  
  
  # Wait for component to be healthy
  if ! check_health "http://localhost:3000/health" 30 2; then
    echo "demo-consumer failed health check, exiting"
    cleanup
    exit 1
  fi
  
}


# Start the pipeline components in dependency order
echo "Starting pipeline: $PIPELINE_NAME"

start_stellar_source

start_ttp_processor

start_demo_consumer


echo "Pipeline started successfully"
echo "Logs available in: $LOG_DIR"
echo "Press Ctrl+C to stop the pipeline"

# Keep the script running
while true; do
  sleep 1
  
  # Check if any process has exited
  for component in "${!PIDS[@]}"; do
    pid=${PIDS[$component]}
    if ! kill -0 "$pid" 2>/dev/null; then
      echo "Component $component (PID: $pid) has exited"
      if [ "$RESTART_POLICY" = "always" ]; then
        echo "Restarting component $component..."
        start_$component
      elif [ "$RESTART_POLICY" = "on-failure" ]; then
        wait "$pid" || start_$component
      else
        echo "Component $component exited, shutting down pipeline"
        cleanup
        exit 1
      fi
    fi
  done
done
