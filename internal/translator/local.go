package translator

import (
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/withobsrvr/flowctl/internal/config"
	"github.com/withobsrvr/flowctl/internal/model"
	"github.com/withobsrvr/flowctl/internal/utils/logger"
	"go.uber.org/zap"
)

// LocalGenerator implements Generator for local execution
type LocalGenerator struct{}

// LocalRunConfig represents the local run configuration
type LocalRunConfig struct {
	Name          string
	Components    []LocalComponent
	EnvFile       string
	LogDir        string
	RestartPolicy string
}

// LocalComponent represents a component in the local run configuration
type LocalComponent struct {
	ID              string
	Name            string
	Type            string
	Command         string
	Args            []string
	EnvVars         map[string]string
	Ports           []int
	HealthCheck     string
	HealthCheckPort int
	DependsOn       []string
	WaitFor         string
	LogFile         string
}

const localRunnerTemplate = `#!/bin/bash

# {{ .Name }} - Local Pipeline Runner
# Generated by flowctl

set -e

# Configuration
LOG_DIR="{{ .LogDir }}"
ENV_FILE="{{ .EnvFile }}"
RESTART_POLICY="{{ .RestartPolicy }}"
PIPELINE_NAME="{{ .Name }}"

# Create log directory
mkdir -p "$LOG_DIR"

# Process tracking
declare -A PIDS

# Cleanup function
cleanup() {
  echo "Shutting down pipeline..."
  for pid in "${PIDS[@]}"; do
    if kill -0 "$pid" 2>/dev/null; then
      echo "Stopping process $pid"
      kill "$pid" || true
    fi
  done
  echo "Pipeline shutdown complete"
  exit 0
}

# Set up signal handling
trap cleanup SIGINT SIGTERM

# Load environment variables
if [ -f "$ENV_FILE" ]; then
  echo "Loading environment from $ENV_FILE"
  set -a
  source "$ENV_FILE"
  set +a
fi

# Health check function
check_health() {
  local url="$1"
  local max_retries="$2"
  local retry_delay="$3"
  local retries=0

  echo "Checking health at $url"
  until $(curl --output /dev/null --silent --fail "$url"); do
    retries=$((retries + 1))
    if [ "$retries" -ge "$max_retries" ]; then
      echo "Health check failed after $retries attempts"
      return 1
    fi
    echo "Health check attempt $retries failed, retrying in ${retry_delay}s..."
    sleep "$retry_delay"
  done
  echo "Health check passed"
  return 0
}

# Start all components
{{ range .Components }}
start_{{ .ID }}() {
  echo "Starting {{ .Name }} ({{ .Type }})..."
  
  {{ if .DependsOn }}
  echo "Waiting for dependencies: {{ .WaitFor }}"
  {{ .WaitFor }}
  {{ end }}
  
  # Create component log file
  local log_file="${LOG_DIR}/{{ .LogFile }}"
  touch "$log_file"
  
  # Start component with environment variables
  {{ .Command }} {{ range .Args }}"{{ . }}" {{ end }} > "$log_file" 2>&1 &
  local pid=$!
  PIDS[{{ .ID }}]=$pid
  echo "Started {{ .Name }} with PID: $pid"
  
  {{ if .HealthCheck }}
  # Wait for component to be healthy
  if ! check_health "{{ .HealthCheck }}" 30 2; then
    echo "{{ .Name }} failed health check, exiting"
    cleanup
    exit 1
  fi
  {{ end }}
}
{{ end }}

# Start the pipeline components in dependency order
echo "Starting pipeline: $PIPELINE_NAME"
{{ range .Components }}
start_{{ .ID }}
{{ end }}

echo "Pipeline started successfully"
echo "Logs available in: $LOG_DIR"
echo "Press Ctrl+C to stop the pipeline"

# Keep the script running
while true; do
  sleep 1
  
  # Check if any process has exited
  for component in "${!PIDS[@]}"; do
    pid=${PIDS[$component]}
    if ! kill -0 "$pid" 2>/dev/null; then
      echo "Component $component (PID: $pid) has exited"
      if [ "$RESTART_POLICY" = "always" ]; then
        echo "Restarting component $component..."
        start_$component
      elif [ "$RESTART_POLICY" = "on-failure" ]; then
        wait "$pid" || start_$component
      else
        echo "Component $component exited, shutting down pipeline"
        cleanup
        exit 1
      fi
    fi
  done
done
`

const envFileTemplate = `# Environment variables for {{ .Name }}
# Generated by flowctl

# Global environment variables
FLOWCTL_PIPELINE_NAME={{ .Name }}
FLOWCTL_LOG_DIR={{ .LogDir }}

# Component-specific environment variables
{{ range .Components }}
# {{ .Name }} ({{ .Type }}) environment variables
{{ range $key, $value := .EnvVars }}{{ $key }}={{ $value }}
{{ end }}
{{ end }}
`

// Generate produces local run configuration
func (g *LocalGenerator) Generate(cfg *config.Config, opts model.TranslationOptions) ([]byte, error) {
	logger.Debug("Generating local run configuration")

	// Validate the configuration
	if err := g.Validate(cfg); err != nil {
		return nil, err
	}

	// Extract or generate pipeline name
	pipelineName := opts.ResourcePrefix
	if pipelineName == "" {
		pipelineName = "flowctl-pipeline"
	}

	// Create local run configuration
	runConfig := LocalRunConfig{
		Name:          pipelineName,
		Components:    make([]LocalComponent, 0),
		EnvFile:       ".env." + pipelineName,
		LogDir:        "logs/" + pipelineName,
		RestartPolicy: "on-failure", // Default restart policy
	}

	// Process source
	sourceID := sanitizeID(cfg.Source.Type)
	sourceName := cfg.Source.Type
	sourceComponent := buildLocalComponent(sourceID, sourceName, "source", cfg.Source.Params, []string{})
	runConfig.Components = append(runConfig.Components, sourceComponent)

	// Process processors
	var processorIDs []string
	for _, proc := range cfg.Processors {
		procID := sanitizeID(proc.Name)
		processorIDs = append(processorIDs, procID)
		procComponent := buildLocalComponent(procID, proc.Name, "processor", proc.Params, []string{sourceID})
		runConfig.Components = append(runConfig.Components, procComponent)
	}

	// Process sink
	sinkID := sanitizeID(cfg.Sink.Type)
	sinkName := cfg.Sink.Type
	sinkComponent := buildLocalComponent(sinkID, sinkName, "sink", cfg.Sink.Params, processorIDs)
	runConfig.Components = append(runConfig.Components, sinkComponent)

	// Generate the runner script
	tmpl, err := template.New("local_runner").Parse(localRunnerTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var runnerScript strings.Builder
	if err := tmpl.Execute(&runnerScript, runConfig); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Generate the environment file
	envTmpl, err := template.New("env_file").Parse(envFileTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse env template: %w", err)
	}

	var envFile strings.Builder
	if err := envTmpl.Execute(&envFile, runConfig); err != nil {
		return nil, fmt.Errorf("failed to execute env template: %w", err)
	}

	// Write the environment file
	if opts.OutputPath != "" {
		envFilePath := filepath.Join(filepath.Dir(opts.OutputPath), runConfig.EnvFile)
		logger.Info("Writing environment file", zap.String("path", envFilePath))
		if err := writeToFile(envFilePath, []byte(envFile.String())); err != nil {
			logger.Warn("Failed to write environment file", zap.Error(err))
		}
	}

	// Return the runner script
	return []byte(runnerScript.String()), nil
}

// Validate checks if the config can be translated to local execution
func (g *LocalGenerator) Validate(cfg *config.Config) error {
	logger.Debug("Validating configuration for local execution")

	// Basic validation that pipeline components are defined
	if cfg.Source.Type == "" {
		return fmt.Errorf("source type must be specified")
	}

	if len(cfg.Processors) == 0 {
		return fmt.Errorf("at least one processor must be defined")
	}

	if cfg.Sink.Type == "" {
		return fmt.Errorf("sink type must be specified")
	}

	// Check for required parameters in components
	if _, ok := cfg.Source.Params["command"]; !ok {
		return fmt.Errorf("source must have a 'command' parameter")
	}

	for i, proc := range cfg.Processors {
		if _, ok := proc.Params["command"]; !ok {
			return fmt.Errorf("processor %d (%s) must have a 'command' parameter", i, proc.Name)
		}
	}

	if _, ok := cfg.Sink.Params["command"]; !ok {
		return fmt.Errorf("sink must have a 'command' parameter")
	}

	return nil
}

// Helper functions

// sanitizeID sanitizes a name to be used as a component ID
func sanitizeID(name string) string {
	// Replace any non-alphanumeric character with an underscore
	sanitized := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)

	// Ensure ID starts with a letter
	if len(sanitized) > 0 && !((sanitized[0] >= 'a' && sanitized[0] <= 'z') || (sanitized[0] >= 'A' && sanitized[0] <= 'Z')) {
		sanitized = "component_" + sanitized
	}

	return sanitized
}

// buildLocalComponent creates a LocalComponent from component parameters
func buildLocalComponent(id, name, cType string, params map[string]interface{}, dependsOn []string) LocalComponent {
	component := LocalComponent{
		ID:      id,
		Name:    name,
		Type:    cType,
		EnvVars: make(map[string]string),
		LogFile: fmt.Sprintf("%s.log", id),
	}

	// Extract command
	if cmd, ok := params["command"].([]interface{}); ok && len(cmd) > 0 {
		component.Command = fmt.Sprintf("%v", cmd[0])
		if len(cmd) > 1 {
			component.Args = make([]string, len(cmd)-1)
			for i, arg := range cmd[1:] {
				component.Args[i] = fmt.Sprintf("%v", arg)
			}
		}
	} else if cmdStr, ok := params["command"].(string); ok {
		component.Command = cmdStr
	}

	// Extract environment variables
	if env, ok := params["env"].(map[string]interface{}); ok {
		for k, v := range env {
			component.EnvVars[k] = fmt.Sprintf("%v", v)
		}
	}

	// Extract ports
	if ports, ok := params["ports"].([]interface{}); ok {
		component.Ports = make([]int, 0, len(ports))
		for _, p := range ports {
			if port, ok := p.(int); ok {
				component.Ports = append(component.Ports, port)
			} else if portStr, ok := p.(string); ok {
				var port int
				if _, err := fmt.Sscanf(portStr, "%d", &port); err == nil {
					component.Ports = append(component.Ports, port)
				}
			}
		}
	}

	// Extract health check
	if health, ok := params["health_check"].(string); ok && health != "" {
		component.HealthCheck = health
		component.HealthCheckPort = 8080 // Default health check port

		// Try to extract health check port from parameters
		if hcPort, ok := params["health_port"].(int); ok {
			component.HealthCheckPort = hcPort
		} else if hcPortStr, ok := params["health_port"].(string); ok {
			var port int
			if _, err := fmt.Sscanf(hcPortStr, "%d", &port); err == nil {
				component.HealthCheckPort = port
			}
		}

		// Format full health check URL
		if !strings.HasPrefix(component.HealthCheck, "http") {
			component.HealthCheck = fmt.Sprintf("http://localhost:%d%s", 
				component.HealthCheckPort, 
				component.HealthCheck)
		}
	}

	// Set dependencies
	component.DependsOn = dependsOn

	// Build wait-for command if dependencies exist
	if len(dependsOn) > 0 {
		var waitCmds []string
		for _, dep := range dependsOn {
			waitCmds = append(waitCmds, fmt.Sprintf("while ! kill -0 \"${PIDS[%s]}\" 2>/dev/null; do sleep 1; done", dep))
		}
		component.WaitFor = strings.Join(waitCmds, " && ")
	}

	return component
}